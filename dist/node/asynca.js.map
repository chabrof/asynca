{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/g179735/temp/asynca/src/Abstract.js","webpack:////home/g179735/temp/asynca/src/FifoCache.js","webpack:////home/g179735/temp/asynca/src/SidePrefetchAbstract.js","webpack:////home/g179735/temp/asynca/src/index.js","webpack:////home/g179735/temp/asynca/src/SidePrefetch.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","Abstract","init","this","_items","_prefixLog","_history","_itemIdxToCacheIdx","[object Object]","itemIdx","oldItemIdx","oldCacheIdx","cacheIdx","unallocPromise","length","cache","historyIdx","unallocStrategie","console","log","undefined","splice","free","push","then","alloc","assert","getAsync","_cache","Promise","resolve","forEach","cbk","map","reduce","Array","_manageSetGet","items","attrib","FifoCache_FifoCache","SidePrefetchAbstract_SidePrefetchAbstract","getSignedMinDistance","itemOrigIdx","itemDestIdx","nbItems","cyclic","distance","prefetchingOff","_prefetchingOn","prefetchingOn","src_Abstract","src_FifoCache","src_SidePrefetch","super","_cyclic","_nbItems","_rightPrefetchSize","_leftPrefetchSize","_sidePrefetchOffOnce","ct","_curItemIdx","group","ret","tmpItemIdx","modTmpItemIdx","groupEnd","prefetchSideSize","leftPrefetchSideSize","rightPrefetchSideSize"],"mappings":"2BACA,IAAAA,KAMA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QA8CA,OAzCAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAGA3B,EAAA4B,KAIA5B,IAAA6B,EAAA,+CCzEaC,EAEXC,OACOC,KAAKC,SACVD,KAAKE,WAAa,YAElBF,KAAKG,YACLH,KAAKI,uBAQPC,aAAcC,GACZ,IAAIC,EACAC,EACAC,EACAC,EAEJ,GAAIV,KAAKG,SAASQ,QAAUX,KAAKY,MAAMD,OAAQ,CAM7C,IAAIE,EAAab,KAAKc,iBAAiBR,GACvCC,EAAaP,KAAKG,SAASU,GAAYP,QACvCE,EAAcR,KAAKG,SAASU,GAAYJ,SAGxCM,QAAQC,IAAIhB,KAAKE,yCAA0CM,qBAA+BD,KAC1FP,KAAKY,MAAMJ,QAAeS,EAC1BjB,KAAKI,mBAAmBG,QAAcU,EACtCjB,KAAKG,SAASe,OAAOL,EAAY,GACjCH,EAAiBV,KAAKmB,KAAKZ,GAG3BE,EAAWD,OAGXC,EAAWT,KAAKG,SAASQ,OAQ3B,OAJAX,KAAKG,SAASiB,MAAMd,QAAYA,EAASG,SAAaA,IACtDT,KAAKY,MAAMH,GAAYT,KAAKC,OAAOK,GACnCN,KAAKI,mBAAmBE,GAAWG,EACnCM,QAAQC,IAAIhB,KAAKE,8BAA+BO,sBAA6BH,KACtEI,EAAiBA,EAAeW,KAAK,SAA2CJ,IAArCjB,KAAKI,mBAAmBE,GAAyBN,KAAKsB,MAAMhB,GAAW,MAAQN,KAAKsB,MAAMhB,GAQ9IQ,iBAAkBR,GAChBS,QAAQQ,QAAO,EAAO,iCAOxBD,MAAOhB,GACLS,QAAQQ,QAAO,EAAO,iCAOxBJ,KAAMb,GACJS,QAAQQ,QAAO,EAAO,iCAOxBC,SAAUlB,GACR,YAAyCW,IAArCjB,KAAKI,mBAAmBE,IAC1BS,QAAQC,IAAIhB,KAAKE,WAAY,QAAUI,EAAU,8BAC1CN,KAAKyB,OAAOnB,KAEnBS,QAAQC,IAAIhB,KAAKE,WAAY,QAAUI,EAAU,gCAC1CoB,QAAQC,QAAQ3B,KAAKC,OAAOK,KAQvCpB,IAAKoB,GAIH,OAFAN,KAAKwB,SAASlB,GAEPN,KAAKC,OAAOK,GAMrBc,KAAMhC,GAIJ,OAHA2B,QAAQQ,OAAOvB,KAAKC,QAAUD,KAAKC,OAAOU,OAAQ,4BAElDX,KAAKC,OAAOmB,KAAKhC,GACVY,KAGT4B,QAASC,GAEP,OADA7B,KAAKC,OAAO2B,QAAQC,GACb7B,KAGT8B,IAAKD,GACH,OAAO7B,KAAKC,OAAO6B,IAAID,GAGzBE,OAAQF,GACN,OAAO7B,KAAKC,OAAO8B,OAAOF,GAO5BjB,MAAOxB,GAEL,OADAA,EAAyB,iBAAVA,EAAqB,IAAI4C,MAAM5C,GAASA,EAChDY,KAAKiC,cAAc,SAAU7C,GAGtC8C,MAAO9C,GACL,OAAOY,KAAKiC,cAAc,SAAU7C,GAGtC6C,cAAeE,EAAQ/C,GACrB,OAAKA,GAELY,KAAKmC,GAAU/C,EAEfY,KAAKD,OAEEC,MANYA,KAAKmC,UC1IfC,UAAkBtC,EAS7BgB,iBAAkBR,GAChB,OAAO,SCVE+B,UAA6BD,EAOxCE,qBAAsBC,EAAaC,EAAaC,EAASC,GAAS,GAChE,IAAIC,EAAWH,EAAcD,EAE7B,GAAIG,EACF,GAAIC,EAAW,GAEb,GAAIF,EAAUE,EAAWA,EAAU,QAASF,EAAUE,QAGtD,GAAKF,EAAUE,GAAaA,EAAU,OAAQF,EAAUE,EAI5D,OAAOA,EAOTC,iBACE5C,KAAK6C,gBAAiB,EAOxBC,gBACE9C,KAAK6C,gBAAiB,6HClCnB,MAAME,EAAWjD,EACXkD,EAAYZ,EACZa,gBCJqBZ,EAEhCtC,OACEmD,MAAMnD,OAEFC,KAAKC,SAETD,KAAKmD,QAAUnD,KAAKmD,UAAW,EAC/BnD,KAAKoD,SAAWpD,KAAKC,OAAOU,OAC5BX,KAAKqD,wBAAkDpC,IAA5BjB,KAAKqD,mBAAoCrD,KAAKqD,mBAAqBrD,KAAKsD,kBACnGtD,KAAKuD,sBAAuB,EAC5BvD,KAAK6C,gBAAiB,GAQxB/B,iBAAkBR,GAEhB,IAAK,IAAIkD,EAAK,EAAGA,EAAKxD,KAAKG,SAASQ,OAAQ6C,IAAM,CAChD,IAAIb,EAAW3C,KAAKsC,qBAAqBtC,KAAKyD,YAAazD,KAAKG,SAASqD,GAAIlD,QAASN,KAAKoD,SAAUpD,KAAKmD,SAE1G,GAAIR,EAAW3C,KAAKqD,oBAChB,EAAIV,EAAY3C,KAAKsD,kBACvB,OAAOE,EAKX,OAAON,MAAMpC,iBAAiBR,GAOhCpB,IAAKoB,GACHN,KAAKyD,YAAcnD,EAGnBS,QAAQ2C,MAAM1D,KAAKE,WAAY,iBAAkBI,GACjDS,QAAQC,IAAIhB,KAAKE,WAAY,qCAE7B,IAAIyD,EAAMT,MAAMhE,IAAIoB,GAGpB,GAAIN,KAAK6C,eAAgB,CAEvB,IAAK,IAAIe,EAAatD,EAAUN,KAAKsD,kBAAmBM,GAActD,EAAU,EAAGsD,IACjF,GAAIA,EAAa,GACf,GAAI5D,KAAKmD,QAAS,CAChB,IAAIU,EAAgB7D,KAAKkC,MAAMvB,OAASiD,EACxC7C,QAAQC,IAAIhB,KAAKE,WAAY,qBAC7Ba,QAAQC,IAAIhB,KAAKE,WAAY,mBAAoB2D,GACjDX,MAAMhE,IAAI2E,SAGZ9C,QAAQC,IAAIhB,KAAKE,WAAY,qBAC7Ba,QAAQC,IAAIhB,KAAKE,WAAY,mBAAoB0D,GACjDV,MAAMhE,IAAI0E,GAId,IAAK,IAAIA,EAAatD,EAAU,EAAGkD,EAAK,EAAGA,EAAKxD,KAAKqD,mBAAoBO,IAAcJ,IACrF,GAAII,GAAc5D,KAAKkC,MAAMvB,QAC3B,GAAIX,KAAKmD,QAAS,CAChB,IAAIU,EAAgBD,EAAa5D,KAAKkC,MAAMvB,OAC5CI,QAAQC,IAAIhB,KAAKE,WAAY,qBAC7Ba,QAAQC,IAAIhB,KAAKE,WAAY,mBAAoB2D,GACjDX,MAAMhE,IAAI2E,SAGZ9C,QAAQC,IAAIhB,KAAKE,WAAY,qBAC7Ba,QAAQC,IAAIhB,KAAKE,WAAY,mBAAoB0D,GACjDV,MAAMhE,IAAI0E,GAMhB,OAFA7C,QAAQ+C,WAEDH,EAGTI,iBAAkB3E,GAChBY,KAAKiC,cAAc,oBAAqB7C,GAG1C4E,qBAAsB5E,GACpBY,KAAKiC,cAAc,oBAAqB7C,GAG1C6E,sBAAuB7E,GACrBY,KAAKiC,cAAc,qBAAsB7C","file":"asynca.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export class Abstract {\n\n  init () {\n    if (!this._items) return\n    this._prefixLog = \"asynca : \"\n\n    this._history = []\n    this._itemIdxToCacheIdx = []\n  }\n\n  /**\n   * meta method\n   * use a Fifo unallocStrategy\n   * [itemIdx] is the index of the iten in the items array\n   */\n  async _cache (itemIdx) {\n    let oldItemIdx\n    let oldCacheIdx\n    let cacheIdx\n    let unallocPromise\n\n    if (this._history.length >= this.cache.length) {\n      //\n      // No more space in cache => unalloc one elem\n      //\n\n      // search in history withe uallocStrategie\n      let historyIdx = this.unallocStrategie(itemIdx)\n      oldItemIdx = this._history[historyIdx].itemIdx\n      oldCacheIdx = this._history[historyIdx].cacheIdx\n\n      // unalloc the \"good cache elt\"\n      console.log(this._prefixLog, ` get cacheIdx to recycle : ${oldCacheIdx}  => free item : ${oldItemIdx}`)\n      this.cache[oldCacheIdx] = undefined\n      this._itemIdxToCacheIdx[oldItemIdx] = undefined\n      this._history.splice(historyIdx, 1)\n      unallocPromise = this.free(oldItemIdx)\n\n      // use the old cache idx as a new one for new item caching\n      cacheIdx = oldCacheIdx\n    } else {\n      // get the cache Idx (the history tab is not full for the moment historyIdx and cacheIdx are the same)\n      cacheIdx = this._history.length // == historyIdx\n    }\n\n    // Put in cache\n    this._history.push({\"itemIdx\" : itemIdx, \"cacheIdx\" : cacheIdx})\n    this.cache[cacheIdx] = this._items[itemIdx]\n    this._itemIdxToCacheIdx[itemIdx] = cacheIdx\n    console.log(this._prefixLog, ` use cacheIdx : ${cacheIdx}  => alloc item : ${itemIdx}`)\n    return unallocPromise ? unallocPromise.then(() => this._itemIdxToCacheIdx[itemIdx] !== undefined ? this.alloc(itemIdx) : null) : this.alloc(itemIdx)\n  }\n\n  /**\n   * Defines the strategy for unallocate item in cache\n   * [itemIdx] is the index of the item\n   * @return {number} index in the [_history]\n   */\n  unallocStrategie (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * @abstract\n   * [itemIdx] is the index in the list of items which must be computed\n   */\n  alloc (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * @abstract\n   * [itemIdx] is the index in the list of items which must be free (un-computed)\n   */\n  free (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * Get a Promise to the wished item\n   * it uses precomputed item in cache (if available) or ask for a computation\n   */\n  getAsync (itemIdx) {\n    if (this._itemIdxToCacheIdx[itemIdx] === undefined) {\n      console.log(this._prefixLog, 'item(' + itemIdx + ') not cached => compute it')\n      return this._cache(itemIdx)\n    } else {\n      console.log(this._prefixLog, 'item(' + itemIdx + ') already in cache => get it')\n      return Promise.resolve(this._items[itemIdx])\n    }\n  }\n\n  /**\n   * Get Item which has been computed or .. not !\n   * uses precomputed item in cache (if available) or ask for a computation\n   */\n  get (itemIdx) {\n    // First of all, call the whole machinery\n    this.getAsync(itemIdx)\n    // ... and simply return the item\n    return this._items[itemIdx]\n  }\n\n  /**\n   * Push one item in list of items\n   */\n  push (value) {\n    console.assert(this._items && this._items.length, 'items is not initialysed')\n\n    this._items.push(value)\n    return this\n  }\n\n  forEach (cbk) {\n    this._items.forEach(cbk)\n    return this\n  }\n\n  map (cbk) {\n    return this._items.map(cbk)\n  }\n\n  reduce (cbk) {\n    return this._items.reduce(cbk)\n  }\n\n  //\n  // Getters/Setters\n  //\n\n  cache (value) {\n    value = typeof value === 'number' ? new Array(value) : value\n    return this._manageSetGet('_cache', value)\n  }\n\n  items (value) {\n    return this._manageSetGet('_items', value)\n  }\n\n  _manageSetGet (attrib, value) {\n    if (!value) return this[attrib]\n\n    this[attrib] = value\n\n    this.init()\n\n    return this\n  }\n}\n","import { Abstract } from \"./Abstract\"\n\nexport class FifoCache extends Abstract {\n\n  /**\n   * Defines the strategy for unallocate item in cache\n   * We implement a very very hard to understand complex strategy\n   *   => we choose to unallocate the oldest computed item (first item idx in the history : 0)\n   * [itemIdx] is the index of the item\n   * @return {number} index in the [_history]\n   */\n  unallocStrategie (itemIdx) {\n    return 0\n  }\n}\n","import { FifoCache } from \"./FifoCache\"\n\nexport class SidePrefetchAbstract extends FifoCache {\n\n  /**\n   * Get distance between items\n   * distance > 0 distance to the right\n   * distance < 0 distance to the left\n   */\n  getSignedMinDistance (itemOrigIdx, itemDestIdx, nbItems, cyclic = false) {\n    let distance = itemDestIdx - itemOrigIdx\n\n    if (cyclic) {\n      if (distance > 0) {\n        // We found a \"left distance\" ..accross 0 index\n        if (nbItems - distance < distance) return -(nbItems - distance)\n      } else {\n        // We found a \"right distance\" ..accross last index\n        if ((nbItems + distance) < -distance) return (nbItems + distance)\n      }\n    }\n\n    return distance\n  }\n\n  /**\n   *  you can unactivate prefetch\n   *  use this, before the get call\n   */\n  prefetchingOff () {\n    this._prefetchingOn = false\n  }\n\n  /**\n   *  you can reactivate prefetch\n   *  use this, before the get call\n   */\n  prefetchingOn () {\n    this._prefetchingOn = true\n  }\n}\n","import { Abstract as Ab } from \"./Abstract\"\r\nimport { FifoCache as FCh } from \"./FifoCache\"\r\nimport { SidePrefetch as SPf } from \"./SidePrefetch\"\r\n\r\nexport const Abstract = Ab\r\nexport const FifoCache = FCh\r\nexport const SidePrefetch = SPf\r\n","import { SidePrefetchAbstract } from \"./SidePrefetchAbstract\"\n\nexport class SidePrefetch extends SidePrefetchAbstract {\n\n  init () {\n    super.init()\n\n    if (this._items) return\n\n    this._cyclic = this._cyclic || false\n    this._nbItems = this._items.length\n    this._rightPrefetchSize = (this._rightPrefetchSize !== undefined) ? this._rightPrefetchSize : this._leftPrefetchSize\n    this._sidePrefetchOffOnce = false\n    this._prefetchingOn = true\n  }\n\n  /**\n   * Returns the index ([int]) of the item to be unallocated in the [_history]\n   * overrides meta method\n   * computes distance and get the right item to unallocate\n   */\n  unallocStrategie (itemIdx) {\n    //  We do NOT use the arg [itemIdx] but _curItemIdx (which represents the \"wished\" item and not the right of left precomputed items)\n    for (let ct = 0; ct < this._history.length; ct++) {\n      let distance = this.getSignedMinDistance(this._curItemIdx, this._history[ct].itemIdx, this._nbItems, this._cyclic)\n\n      if (distance > this._rightPrefetchSize ||\n         (0 - distance) > this._leftPrefetchSize) {\n        return ct\n      }\n    }\n\n    // By default, we use the FifoCache method, wich unallocate the \"oldest\" cached item\n    return super.unallocStrategie(itemIdx)\n  }\n\n  /**\n   * Main method to get an item\n   * computes cache and prefetch automaticaly\n   */\n  get (itemIdx) {\n    this._curItemIdx = itemIdx\n\n    // Current item\n    console.group(this._prefixLog, 'Get current : ', itemIdx)\n    console.log(this._prefixLog, '/////////////////////////////////')\n\n    let ret = super.get(itemIdx)\n\n    // Prefetch\n    if (this._prefetchingOn) {\n      // Left items\n      for (let tmpItemIdx = itemIdx - this._leftPrefetchSize; tmpItemIdx <= itemIdx - 1; tmpItemIdx++) {\n        if (tmpItemIdx < 0) {\n          if (this._cyclic) {\n            let modTmpItemIdx = this.items.length + tmpItemIdx\n            console.log(this._prefixLog, '/////////////////')\n            console.log(this._prefixLog, 'Prefetch left : ', modTmpItemIdx)\n            super.get(modTmpItemIdx)\n          }\n        } else {\n          console.log(this._prefixLog, '/////////////////')\n          console.log(this._prefixLog, 'Prefetch left : ', tmpItemIdx)\n          super.get(tmpItemIdx)\n        }\n      }\n      // Right items\n      for (let tmpItemIdx = itemIdx + 1, ct = 0; ct < this._rightPrefetchSize; tmpItemIdx++, ct++) {\n        if (tmpItemIdx >= this.items.length) {\n          if (this._cyclic) {\n            let modTmpItemIdx = tmpItemIdx - this.items.length\n            console.log(this._prefixLog, '/////////////////')\n            console.log(this._prefixLog, 'Prefetch right :', modTmpItemIdx)\n            super.get(modTmpItemIdx)\n          }\n        } else {\n          console.log(this._prefixLog, '/////////////////')\n          console.log(this._prefixLog, 'Prefetch right :', tmpItemIdx)\n          super.get(tmpItemIdx)\n        }\n      }\n    }\n    console.groupEnd()\n\n    return ret\n  }\n\n  prefetchSideSize (value) {\n    this._manageSetGet('_leftPrefetchSize', value)\n  }\n\n  leftPrefetchSideSize (value) {\n    this._manageSetGet('_leftPrefetchSize', value)\n  }\n\n  rightPrefetchSideSize (value) {\n    this._manageSetGet('_rightPrefetchSize', value)\n  }\n}\n"],"sourceRoot":""}