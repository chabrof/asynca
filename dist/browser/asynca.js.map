{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:////home/g179735/temp/asynca/src/Abstract.js","webpack:////home/g179735/temp/asynca/src/FifoCache.js","webpack:////home/g179735/temp/asynca/src/SidePrefetchAbstract.js","webpack:////home/g179735/temp/asynca/src/index.js","webpack:////home/g179735/temp/asynca/src/SidePrefetch.js"],"names":["root","factory","exports","module","define","amd","a","i","window","e","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","t","Abstract","init","this","_items","_prefixLog","_history","_itemIdxToCacheIdx","[object Object]","itemIdx","oldItemIdx","oldCacheIdx","cacheIdx","unallocPromise","length","cache","historyIdx","unallocStrategie","console","log","splice","free","push","then","alloc","assert","getAsync","_cache","Promise","resolve","forEach","cbk","map","reduce","Array","_manageSetGet","items","attrib","FifoCache_FifoCache","src_Abstract","src_FifoCache","src_SidePrefetch","getSignedMinDistance","itemOrigIdx","itemDestIdx","nbItems","cyclic","distance","prefetchingOff","_prefetchingOn","prefetchingOn","super","_cyclic","_nbItems","_rightPrefetchSize","_leftPrefetchSize","_sidePrefetchOffOnce","ct","_curItemIdx","group","ret","tmpItemIdx","modTmpItemIdx","groupEnd","prefetchSideSize","leftPrefetchSideSize","rightPrefetchSideSize"],"mappings":"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","file":"asynca.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export class Abstract {\n\n  init () {\n    if (!this._items) return\n    this._prefixLog = \"asynca : \"\n\n    this._history = []\n    this._itemIdxToCacheIdx = []\n  }\n\n  /**\n   * meta method\n   * use a Fifo unallocStrategy\n   * [itemIdx] is the index of the iten in the items array\n   */\n  async _cache (itemIdx) {\n    let oldItemIdx\n    let oldCacheIdx\n    let cacheIdx\n    let unallocPromise\n\n    if (this._history.length >= this.cache.length) {\n      //\n      // No more space in cache => unalloc one elem\n      //\n\n      // search in history withe uallocStrategie\n      let historyIdx = this.unallocStrategie(itemIdx)\n      oldItemIdx = this._history[historyIdx].itemIdx\n      oldCacheIdx = this._history[historyIdx].cacheIdx\n\n      // unalloc the \"good cache elt\"\n      console.log(this._prefixLog, ` get cacheIdx to recycle : ${oldCacheIdx}  => free item : ${oldItemIdx}`)\n      this.cache[oldCacheIdx] = undefined\n      this._itemIdxToCacheIdx[oldItemIdx] = undefined\n      this._history.splice(historyIdx, 1)\n      unallocPromise = this.free(oldItemIdx)\n\n      // use the old cache idx as a new one for new item caching\n      cacheIdx = oldCacheIdx\n    } else {\n      // get the cache Idx (the history tab is not full for the moment historyIdx and cacheIdx are the same)\n      cacheIdx = this._history.length // == historyIdx\n    }\n\n    // Put in cache\n    this._history.push({\"itemIdx\" : itemIdx, \"cacheIdx\" : cacheIdx})\n    this.cache[cacheIdx] = this._items[itemIdx]\n    this._itemIdxToCacheIdx[itemIdx] = cacheIdx\n    console.log(this._prefixLog, ` use cacheIdx : ${cacheIdx}  => alloc item : ${itemIdx}`)\n    return unallocPromise ? unallocPromise.then(() => this._itemIdxToCacheIdx[itemIdx] !== undefined ? this.alloc(itemIdx) : null) : this.alloc(itemIdx)\n  }\n\n  /**\n   * Defines the strategy for unallocate item in cache\n   * [itemIdx] is the index of the item\n   * @return {number} index in the [_history]\n   */\n  unallocStrategie (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * @abstract\n   * [itemIdx] is the index in the list of items which must be computed\n   */\n  alloc (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * @abstract\n   * [itemIdx] is the index in the list of items which must be free (un-computed)\n   */\n  free (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * Get a Promise to the wished item\n   * it uses precomputed item in cache (if available) or ask for a computation\n   */\n  getAsync (itemIdx) {\n    if (this._itemIdxToCacheIdx[itemIdx] === undefined) {\n      console.log(this._prefixLog, 'item(' + itemIdx + ') not cached => compute it')\n      return this._cache(itemIdx)\n    } else {\n      console.log(this._prefixLog, 'item(' + itemIdx + ') already in cache => get it')\n      return Promise.resolve(this._items[itemIdx])\n    }\n  }\n\n  /**\n   * Get Item which has been computed or .. not !\n   * uses precomputed item in cache (if available) or ask for a computation\n   */\n  get (itemIdx) {\n    // First of all, call the whole machinery\n    this.getAsync(itemIdx)\n    // ... and simply return the item\n    return this._items[itemIdx]\n  }\n\n  /**\n   * Push one item in list of items\n   */\n  push (value) {\n    console.assert(this._items && this._items.length, 'items is not initialysed')\n\n    this._items.push(value)\n    return this\n  }\n\n  forEach (cbk) {\n    this._items.forEach(cbk)\n    return this\n  }\n\n  map (cbk) {\n    return this._items.map(cbk)\n  }\n\n  reduce (cbk) {\n    return this._items.reduce(cbk)\n  }\n\n  //\n  // Getters/Setters\n  //\n\n  cache (value) {\n    value = typeof value === 'number' ? new Array(value) : value\n    return this._manageSetGet('_cache', value)\n  }\n\n  items (value) {\n    return this._manageSetGet('_items', value)\n  }\n\n  _manageSetGet (attrib, value) {\n    if (!value) return this[attrib]\n\n    this[attrib] = value\n\n    this.init()\n\n    return this\n  }\n}\n","import { Abstract } from \"./Abstract\"\n\nexport class FifoCache extends Abstract {\n\n  /**\n   * Defines the strategy for unallocate item in cache\n   * We implement a very very hard to understand complex strategy\n   *   => we choose to unallocate the oldest computed item (first item idx in the history : 0)\n   * [itemIdx] is the index of the item\n   * @return {number} index in the [_history]\n   */\n  unallocStrategie (itemIdx) {\n    return 0\n  }\n}\n","import { FifoCache } from \"./FifoCache\"\n\nexport class SidePrefetchAbstract extends FifoCache {\n\n  /**\n   * Get distance between items\n   * distance > 0 distance to the right\n   * distance < 0 distance to the left\n   */\n  getSignedMinDistance (itemOrigIdx, itemDestIdx, nbItems, cyclic = false) {\n    let distance = itemDestIdx - itemOrigIdx\n\n    if (cyclic) {\n      if (distance > 0) {\n        // We found a \"left distance\" ..accross 0 index\n        if (nbItems - distance < distance) return -(nbItems - distance)\n      } else {\n        // We found a \"right distance\" ..accross last index\n        if ((nbItems + distance) < -distance) return (nbItems + distance)\n      }\n    }\n\n    return distance\n  }\n\n  /**\n   *  you can unactivate prefetch\n   *  use this, before the get call\n   */\n  prefetchingOff () {\n    this._prefetchingOn = false\n  }\n\n  /**\n   *  you can reactivate prefetch\n   *  use this, before the get call\n   */\n  prefetchingOn () {\n    this._prefetchingOn = true\n  }\n}\n","import { Abstract as Ab } from \"./Abstract\"\r\nimport { FifoCache as FCh } from \"./FifoCache\"\r\nimport { SidePrefetch as SPf } from \"./SidePrefetch\"\r\n\r\nexport const Abstract = Ab\r\nexport const FifoCache = FCh\r\nexport const SidePrefetch = SPf\r\n","import { SidePrefetchAbstract } from \"./SidePrefetchAbstract\"\n\nexport class SidePrefetch extends SidePrefetchAbstract {\n\n  init () {\n    super.init()\n\n    if (this._items) return\n\n    this._cyclic = this._cyclic || false\n    this._nbItems = this._items.length\n    this._rightPrefetchSize = (this._rightPrefetchSize !== undefined) ? this._rightPrefetchSize : this._leftPrefetchSize\n    this._sidePrefetchOffOnce = false\n    this._prefetchingOn = true\n  }\n\n  /**\n   * Returns the index ([int]) of the item to be unallocated in the [_history]\n   * overrides meta method\n   * computes distance and get the right item to unallocate\n   */\n  unallocStrategie (itemIdx) {\n    //  We do NOT use the arg [itemIdx] but _curItemIdx (which represents the \"wished\" item and not the right of left precomputed items)\n    for (let ct = 0; ct < this._history.length; ct++) {\n      let distance = this.getSignedMinDistance(this._curItemIdx, this._history[ct].itemIdx, this._nbItems, this._cyclic)\n\n      if (distance > this._rightPrefetchSize ||\n         (0 - distance) > this._leftPrefetchSize) {\n        return ct\n      }\n    }\n\n    // By default, we use the FifoCache method, wich unallocate the \"oldest\" cached item\n    return super.unallocStrategie(itemIdx)\n  }\n\n  /**\n   * Main method to get an item\n   * computes cache and prefetch automaticaly\n   */\n  get (itemIdx) {\n    this._curItemIdx = itemIdx\n\n    // Current item\n    console.group(this._prefixLog, 'Get current : ', itemIdx)\n    console.log(this._prefixLog, '/////////////////////////////////')\n\n    let ret = super.get(itemIdx)\n\n    // Prefetch\n    if (this._prefetchingOn) {\n      // Left items\n      for (let tmpItemIdx = itemIdx - this._leftPrefetchSize; tmpItemIdx <= itemIdx - 1; tmpItemIdx++) {\n        if (tmpItemIdx < 0) {\n          if (this._cyclic) {\n            let modTmpItemIdx = this.items.length + tmpItemIdx\n            console.log(this._prefixLog, '/////////////////')\n            console.log(this._prefixLog, 'Prefetch left : ', modTmpItemIdx)\n            super.get(modTmpItemIdx)\n          }\n        } else {\n          console.log(this._prefixLog, '/////////////////')\n          console.log(this._prefixLog, 'Prefetch left : ', tmpItemIdx)\n          super.get(tmpItemIdx)\n        }\n      }\n      // Right items\n      for (let tmpItemIdx = itemIdx + 1, ct = 0; ct < this._rightPrefetchSize; tmpItemIdx++, ct++) {\n        if (tmpItemIdx >= this.items.length) {\n          if (this._cyclic) {\n            let modTmpItemIdx = tmpItemIdx - this.items.length\n            console.log(this._prefixLog, '/////////////////')\n            console.log(this._prefixLog, 'Prefetch right :', modTmpItemIdx)\n            super.get(modTmpItemIdx)\n          }\n        } else {\n          console.log(this._prefixLog, '/////////////////')\n          console.log(this._prefixLog, 'Prefetch right :', tmpItemIdx)\n          super.get(tmpItemIdx)\n        }\n      }\n    }\n    console.groupEnd()\n\n    return ret\n  }\n\n  prefetchSideSize (value) {\n    this._manageSetGet('_leftPrefetchSize', value)\n  }\n\n  leftPrefetchSideSize (value) {\n    this._manageSetGet('_leftPrefetchSize', value)\n  }\n\n  rightPrefetchSideSize (value) {\n    this._manageSetGet('_rightPrefetchSize', value)\n  }\n}\n"],"sourceRoot":""}