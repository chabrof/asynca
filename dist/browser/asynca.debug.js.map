{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:////home/g179735/temp/asynca/src/Abstract.js","webpack:////home/g179735/temp/asynca/src/FifoCache.js","webpack:////home/g179735/temp/asynca/src/SidePrefetch.js","webpack:////home/g179735/temp/asynca/src/SidePrefetchAbstract.js","webpack:////home/g179735/temp/asynca/src/index.js"],"names":["Abstract","init","_items","_prefixLog","_history","_itemIdxToCacheIdx","_cache","itemIdx","oldItemIdx","oldCacheIdx","cacheIdx","unallocPromise","length","cache","historyIdx","unallocStrategie","console","log","undefined","splice","free","push","then","alloc","assert","getAsync","Promise","resolve","get","value","forEach","cbk","map","reduce","Array","_manageSetGet","items","attrib","FifoCache","SidePrefetch","_cyclic","_nbItems","_rightPrefetchSize","_leftPrefetchSize","_sidePrefetchOffOnce","_prefetchingOn","ct","distance","getSignedMinDistance","_curItemIdx","group","ret","tmpItemIdx","modTmpItemIdx","groupEnd","prefetchSideSize","leftPrefetchSideSize","rightPrefetchSideSize","SidePrefetchAbstract","itemOrigIdx","itemDestIdx","nbItems","cyclic","prefetchingOff","prefetchingOn"],"mappings":"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","file":"asynca.debug.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"../../src/index.js\");\n","export class Abstract {\n\n  init () {\n    if (!this._items) return\n    this._prefixLog = \"asynca : \"\n\n    this._history = []\n    this._itemIdxToCacheIdx = []\n  }\n\n  /**\n   * meta method\n   * use a Fifo unallocStrategy\n   * [itemIdx] is the index of the iten in the items array\n   */\n  async _cache (itemIdx) {\n    let oldItemIdx\n    let oldCacheIdx\n    let cacheIdx\n    let unallocPromise\n\n    if (this._history.length >= this.cache.length) {\n      //\n      // No more space in cache => unalloc one elem\n      //\n\n      // search in history withe uallocStrategie\n      let historyIdx = this.unallocStrategie(itemIdx)\n      oldItemIdx = this._history[historyIdx].itemIdx\n      oldCacheIdx = this._history[historyIdx].cacheIdx\n\n      // unalloc the \"good cache elt\"\n      console.log(this._prefixLog, ` get cacheIdx to recycle : ${oldCacheIdx}  => free item : ${oldItemIdx}`)\n      this.cache[oldCacheIdx] = undefined\n      this._itemIdxToCacheIdx[oldItemIdx] = undefined\n      this._history.splice(historyIdx, 1)\n      unallocPromise = this.free(oldItemIdx)\n\n      // use the old cache idx as a new one for new item caching\n      cacheIdx = oldCacheIdx\n    } else {\n      // get the cache Idx (the history tab is not full for the moment historyIdx and cacheIdx are the same)\n      cacheIdx = this._history.length // == historyIdx\n    }\n\n    // Put in cache\n    this._history.push({\"itemIdx\" : itemIdx, \"cacheIdx\" : cacheIdx})\n    this.cache[cacheIdx] = this._items[itemIdx]\n    this._itemIdxToCacheIdx[itemIdx] = cacheIdx\n    console.log(this._prefixLog, ` use cacheIdx : ${cacheIdx}  => alloc item : ${itemIdx}`)\n    return unallocPromise ? unallocPromise.then(() => this._itemIdxToCacheIdx[itemIdx] !== undefined ? this.alloc(itemIdx) : null) : this.alloc(itemIdx)\n  }\n\n  /**\n   * Defines the strategy for unallocate item in cache\n   * [itemIdx] is the index of the item\n   * @return {number} index in the [_history]\n   */\n  unallocStrategie (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * @abstract\n   * [itemIdx] is the index in the list of items which must be computed\n   */\n  alloc (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * @abstract\n   * [itemIdx] is the index in the list of items which must be free (un-computed)\n   */\n  free (itemIdx) {\n    console.assert(false, 'This method must be overriden')\n  }\n\n  /**\n   * Get a Promise to the wished item\n   * it uses precomputed item in cache (if available) or ask for a computation\n   */\n  getAsync (itemIdx) {\n    if (this._itemIdxToCacheIdx[itemIdx] === undefined) {\n      console.log(this._prefixLog, 'item(' + itemIdx + ') not cached => compute it')\n      return this._cache(itemIdx)\n    } else {\n      console.log(this._prefixLog, 'item(' + itemIdx + ') already in cache => get it')\n      return Promise.resolve(this._items[itemIdx])\n    }\n  }\n\n  /**\n   * Get Item which has been computed or .. not !\n   * uses precomputed item in cache (if available) or ask for a computation\n   */\n  get (itemIdx) {\n    // First of all, call the whole machinery\n    this.getAsync(itemIdx)\n    // ... and simply return the item\n    return this._items[itemIdx]\n  }\n\n  /**\n   * Push one item in list of items\n   */\n  push (value) {\n    console.assert(this._items && this._items.length, 'items is not initialysed')\n\n    this._items.push(value)\n    return this\n  }\n\n  forEach (cbk) {\n    this._items.forEach(cbk)\n    return this\n  }\n\n  map (cbk) {\n    return this._items.map(cbk)\n  }\n\n  reduce (cbk) {\n    return this._items.reduce(cbk)\n  }\n\n  //\n  // Getters/Setters\n  //\n\n  cache (value) {\n    value = typeof value === 'number' ? new Array(value) : value\n    return this._manageSetGet('_cache', value)\n  }\n\n  items (value) {\n    return this._manageSetGet('_items', value)\n  }\n\n  _manageSetGet (attrib, value) {\n    if (!value) return this[attrib]\n\n    this[attrib] = value\n\n    this.init()\n\n    return this\n  }\n}\n","import { Abstract } from \"./Abstract\"\n\nexport class FifoCache extends Abstract {\n\n  /**\n   * Defines the strategy for unallocate item in cache\n   * We implement a very very hard to understand complex strategy\n   *   => we choose to unallocate the oldest computed item (first item idx in the history : 0)\n   * [itemIdx] is the index of the item\n   * @return {number} index in the [_history]\n   */\n  unallocStrategie (itemIdx) {\n    return 0\n  }\n}\n","import { SidePrefetchAbstract } from \"./SidePrefetchAbstract\"\n\nexport class SidePrefetch extends SidePrefetchAbstract {\n\n  init () {\n    super.init()\n\n    if (this._items) return\n\n    this._cyclic = this._cyclic || false\n    this._nbItems = this._items.length\n    this._rightPrefetchSize = (this._rightPrefetchSize !== undefined) ? this._rightPrefetchSize : this._leftPrefetchSize\n    this._sidePrefetchOffOnce = false\n    this._prefetchingOn = true\n  }\n\n  /**\n   * Returns the index ([int]) of the item to be unallocated in the [_history]\n   * overrides meta method\n   * computes distance and get the right item to unallocate\n   */\n  unallocStrategie (itemIdx) {\n    //  We do NOT use the arg [itemIdx] but _curItemIdx (which represents the \"wished\" item and not the right of left precomputed items)\n    for (let ct = 0; ct < this._history.length; ct++) {\n      let distance = this.getSignedMinDistance(this._curItemIdx, this._history[ct].itemIdx, this._nbItems, this._cyclic)\n\n      if (distance > this._rightPrefetchSize ||\n         (0 - distance) > this._leftPrefetchSize) {\n        return ct\n      }\n    }\n\n    // By default, we use the FifoCache method, wich unallocate the \"oldest\" cached item\n    return super.unallocStrategie(itemIdx)\n  }\n\n  /**\n   * Main method to get an item\n   * computes cache and prefetch automaticaly\n   */\n  get (itemIdx) {\n    this._curItemIdx = itemIdx\n\n    // Current item\n    console.group(this._prefixLog, 'Get current : ', itemIdx)\n    console.log(this._prefixLog, '/////////////////////////////////')\n\n    let ret = super.get(itemIdx)\n\n    // Prefetch\n    if (this._prefetchingOn) {\n      // Left items\n      for (let tmpItemIdx = itemIdx - this._leftPrefetchSize; tmpItemIdx <= itemIdx - 1; tmpItemIdx++) {\n        if (tmpItemIdx < 0) {\n          if (this._cyclic) {\n            let modTmpItemIdx = this.items.length + tmpItemIdx\n            console.log(this._prefixLog, '/////////////////')\n            console.log(this._prefixLog, 'Prefetch left : ', modTmpItemIdx)\n            super.get(modTmpItemIdx)\n          }\n        } else {\n          console.log(this._prefixLog, '/////////////////')\n          console.log(this._prefixLog, 'Prefetch left : ', tmpItemIdx)\n          super.get(tmpItemIdx)\n        }\n      }\n      // Right items\n      for (let tmpItemIdx = itemIdx + 1, ct = 0; ct < this._rightPrefetchSize; tmpItemIdx++, ct++) {\n        if (tmpItemIdx >= this.items.length) {\n          if (this._cyclic) {\n            let modTmpItemIdx = tmpItemIdx - this.items.length\n            console.log(this._prefixLog, '/////////////////')\n            console.log(this._prefixLog, 'Prefetch right :', modTmpItemIdx)\n            super.get(modTmpItemIdx)\n          }\n        } else {\n          console.log(this._prefixLog, '/////////////////')\n          console.log(this._prefixLog, 'Prefetch right :', tmpItemIdx)\n          super.get(tmpItemIdx)\n        }\n      }\n    }\n    console.groupEnd()\n\n    return ret\n  }\n\n  prefetchSideSize (value) {\n    this._manageSetGet('_leftPrefetchSize', value)\n  }\n\n  leftPrefetchSideSize (value) {\n    this._manageSetGet('_leftPrefetchSize', value)\n  }\n\n  rightPrefetchSideSize (value) {\n    this._manageSetGet('_rightPrefetchSize', value)\n  }\n}\n","import { FifoCache } from \"./FifoCache\"\n\nexport class SidePrefetchAbstract extends FifoCache {\n\n  /**\n   * Get distance between items\n   * distance > 0 distance to the right\n   * distance < 0 distance to the left\n   */\n  getSignedMinDistance (itemOrigIdx, itemDestIdx, nbItems, cyclic = false) {\n    let distance = itemDestIdx - itemOrigIdx\n\n    if (cyclic) {\n      if (distance > 0) {\n        // We found a \"left distance\" ..accross 0 index\n        if (nbItems - distance < distance) return -(nbItems - distance)\n      } else {\n        // We found a \"right distance\" ..accross last index\n        if ((nbItems + distance) < -distance) return (nbItems + distance)\n      }\n    }\n\n    return distance\n  }\n\n  /**\n   *  you can unactivate prefetch\n   *  use this, before the get call\n   */\n  prefetchingOff () {\n    this._prefetchingOn = false\n  }\n\n  /**\n   *  you can reactivate prefetch\n   *  use this, before the get call\n   */\n  prefetchingOn () {\n    this._prefetchingOn = true\n  }\n}\n","import { Abstract as Ab } from \"./Abstract\"\r\nimport { FifoCache as FCh } from \"./FifoCache\"\r\nimport { SidePrefetch as SPf } from \"./SidePrefetch\"\r\n\r\nexport const Abstract = Ab\r\nexport const FifoCache = FCh\r\nexport const SidePrefetch = SPf\r\n"],"sourceRoot":""}